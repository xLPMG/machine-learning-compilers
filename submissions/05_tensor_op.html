

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>5. Tensor Operation Backend &mdash; Machine Learning Compilers  documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../_static/copybutton.css?v=76b2166b" />
      <link rel="stylesheet" type="text/css" href="../_static/graphviz.css?v=4ae1632d" />
      <link rel="stylesheet" type="text/css" href="../_static/sphinx-design.min.css?v=95c83b7e" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=5929fcd5"></script>
      <script src="../_static/doctools.js?v=9bcbadda"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../_static/clipboard.min.js?v=a7894cd8"></script>
      <script src="../_static/copybutton.js?v=f281be69"></script>
      <script src="../_static/design-tabs.js?v=f930bc37"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="6. Einsum Trees" href="06_einsum.html" />
    <link rel="prev" title="4. Code Generation" href="04_code_gen.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            Machine Learning Compilers
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Project Overview</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../project_overview/01_project_information.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../project_overview/02_project_report.html">Project Report</a></li>
<li class="toctree-l1"><a class="reference internal" href="../project_overview/03_user_guide.html">User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../project_overview/04_docu_setup.html">Documentation Setup</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Submissions</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="01_assembly.html">1. Assembly</a></li>
<li class="toctree-l1"><a class="reference internal" href="02_base.html">2. Base</a></li>
<li class="toctree-l1"><a class="reference internal" href="03_neon.html">3. Neon</a></li>
<li class="toctree-l1"><a class="reference internal" href="04_code_gen.html">4. Code Generation</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">5. Tensor Operation Backend</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#user-interface">5.1 User Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="#recursive-loops-over-primitives">5.2 Recursive Loops over Primitives</a></li>
<li class="toctree-l2"><a class="reference internal" href="#performance-benchmarking">5.3 Performance Benchmarking</a></li>
<li class="toctree-l2"><a class="reference internal" href="#shared-memory-parallelization">5.4 Shared Memory Parallelization</a></li>
<li class="toctree-l2"><a class="reference internal" href="#optimization-passes">5.5 Optimization Passes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#primitive-identification">5.5.1 Primitive Identification</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#unary-operation">5.5.1.1 Unary Operation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#binary-operation">5.5.1.2 Binary Operation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#ternary-operation">5.5.1.3 Ternary Operation</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#dimension-splitting">5.5.2 Dimension Splitting</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id3">5.5.3 Shared Memory Parallelization</a></li>
<li class="toctree-l3"><a class="reference internal" href="#dimension-fusion">5.5.4 Dimension Fusion</a></li>
<li class="toctree-l3"><a class="reference internal" href="#performance-benchmarks">5.5.6 Performance Benchmarks</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#unary-operations">5.6 Unary Operations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#backend-extension">5.6.1 Backend Extension</a></li>
<li class="toctree-l3"><a class="reference internal" href="#reference-implementation">5.6.2 Reference Implementation</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="06_einsum.html">6. Einsum Trees</a></li>
<li class="toctree-l1"><a class="reference internal" href="07_individual_phase.html">7. Individual Phase</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../api/namespaces/mini_jit.html">mini_jit</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api/namespaces/mini_jit_benchmarks.html">mini_jit::benchmarks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api/namespaces/mini_jit_converters.html">mini_jit::converters</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api/namespaces/mini_jit_einsum.html">mini_jit::einsum</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api/namespaces/mini_jit_instructions.html">mini_jit::instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api/namespaces/mini_jit_ir.html">mini_jit::ir</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api/namespaces/mini_jit_kernels.html">mini_jit::kernels</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api/namespaces/mini_jit_registers.html">mini_jit::registers</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Machine Learning Compilers</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">5. Tensor Operation Backend</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/submissions/05_tensor_op.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="tensor-operation-backend">
<span id="tensor-op-backend"></span><h1>5. Tensor Operation Backend<a class="headerlink" href="#tensor-operation-backend" title="Link to this heading"></a></h1>
<p>After developing kernels for binary primitives such as GEMM and BRGEMM, as well as kernels for unary primitives like Zero and ReLU, it was now time to implement common interfaces that let the user create tensor operation objects.
The tensor operation backend is not only responsible for setting up and holding the used kernel objects,
but also to block the input and output tensors and execute the kernels accordingly.</p>
<section id="user-interface">
<h2>5.1 User Interface<a class="headerlink" href="#user-interface" title="Link to this heading"></a></h2>
<p>The first component of our tensor operation backend is a function that generates and sets up all necessary kernels.
This <code class="docutils literal notranslate"><span class="pre">setup</span></code> function parses a number of configuration parameters, from which the corresponding kernels and primitives are constructed at runtime.</p>
<p>The first step of the setup is to validate the input parameters for correctness. That includes checking that</p>
<ol class="arabic simple">
<li><p>All input vectors have the same size</p></li>
<li><p>The number of primitive dimensions aligns with the given primitive type</p></li>
<li><p>The chosen primitive types are valid and supported by our backend</p></li>
<li><p>The given data type is supported</p></li>
</ol>
<p>If all supplied parameters are valid, the function scans the execution types of the dimensions for the first primitive dimension and the first sequential dimension.</p>
<div class="literal-block-wrapper docutils container" id="id7">
<div class="code-block-caption"><span class="caption-text">Finding the first primitive and sequential dimension</span><a class="headerlink" href="#id7" title="Link to this code"></a></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">/////////////////////////////////////////////////////////////////////</span>
<span class="c1">// Find first PRIM and SEQ dimensions in exec types</span>
<span class="c1">/////////////////////////////////////////////////////////////////////</span>
<span class="k">auto</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">find</span><span class="p">(</span><span class="n">exec_types</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">exec_types</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="n">exec_t</span><span class="o">::</span><span class="n">prim</span><span class="p">);</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">it</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">exec_types</span><span class="p">.</span><span class="n">end</span><span class="p">())</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">m_id_first_primitive_loop</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">distance</span><span class="p">(</span><span class="n">exec_types</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">it</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">else</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">m_id_first_primitive_loop</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">find</span><span class="p">(</span><span class="n">exec_types</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">exec_types</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="n">exec_t</span><span class="o">::</span><span class="n">seq</span><span class="p">);</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">it</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">exec_types</span><span class="p">.</span><span class="n">end</span><span class="p">())</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">m_id_first_seq_loop</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">distance</span><span class="p">(</span><span class="n">exec_types</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">it</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">else</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">m_id_first_seq_loop</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<p>The function then proceeds to determine the dimension IDs based on their types.</p>
<div class="literal-block-wrapper docutils container" id="id8">
<div class="code-block-caption"><span class="caption-text">Assigning the dimension IDs based on the dimension types</span><a class="headerlink" href="#id8" title="Link to this code"></a></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">/////////////////////////////////////////////////////////////////////</span>
<span class="c1">// Read PRIM dimensions using dim types (No Copy)</span>
<span class="c1">/////////////////////////////////////////////////////////////////////</span>
<span class="c1">// convert to int so negative values are allowed</span>
<span class="kt">int</span><span class="w"> </span><span class="n">l_dim_types_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m_dim_types</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">l_dim_types_size</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">--</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">m_exec_types</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">exec_t</span><span class="o">::</span><span class="n">prim</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">m_dim_id_prim_M</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">-1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">m_dim_types</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">dim_t</span><span class="o">::</span><span class="n">m</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">m_dim_id_prim_M</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">m_dim_id_prim_N</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">-1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">m_dim_types</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">dim_t</span><span class="o">::</span><span class="n">n</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">m_dim_id_prim_N</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">m_dim_id_prim_K</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">-1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">m_dim_types</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">dim_t</span><span class="o">::</span><span class="n">k</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">m_dim_id_prim_K</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">m_dim_id_prim_K</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">-1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">m_dim_id_prim_BR</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">-1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">m_dim_types</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">dim_t</span><span class="o">::</span><span class="n">k</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">m_dim_id_prim_BR</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">/////////////////////////////////////////////////////////////////////</span>
<span class="c1">// Read SEQ and SHARED dimensions</span>
<span class="c1">/////////////////////////////////////////////////////////////////////</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">m_dim_types</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">m_exec_types</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">exec_t</span><span class="o">::</span><span class="n">seq</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">m_dim_types</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">dim_t</span><span class="o">::</span><span class="n">m</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">m_dim_id_seq_M</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">m_dim_types</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">dim_t</span><span class="o">::</span><span class="n">n</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">m_dim_id_seq_N</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">m_dim_types</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">dim_t</span><span class="o">::</span><span class="n">k</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">m_dim_id_seq_K</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">/////////////////////////////////////////////////////////////////////</span>
<span class="c1">// Find M and N dimensions for dim_t::c (PRIM, IDENTITY)</span>
<span class="c1">/////////////////////////////////////////////////////////////////////</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">prim_main</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">ptype_t</span><span class="o">::</span><span class="n">identity</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// For unary operations with dim_t::c, treat the first primitive dimension as M and the second as N</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">m_dim_types</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">m_exec_types</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">exec_t</span><span class="o">::</span><span class="n">prim</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">m_dim_types</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">dim_t</span><span class="o">::</span><span class="n">c</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">m_strides_in0</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">m_dim_id_prim_M</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">else</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">m_dim_id_prim_N</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<p>The next step is to check whether the tensor operation includes a transposition, and to adjust all strides accordingly:</p>
<div class="literal-block-wrapper docutils container" id="id9">
<div class="code-block-caption"><span class="caption-text">Checking for transposition and adjusting strides</span><a class="headerlink" href="#id9" title="Link to this code"></a></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">/////////////////////////////////////////////////////////////////////</span>
<span class="c1">// Check for Transposition</span>
<span class="c1">/////////////////////////////////////////////////////////////////////</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">m_dim_id_prim_M</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">-1</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int64_t</span><span class="w"> </span><span class="n">l_stride_in0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_strides_in0</span><span class="p">[</span><span class="n">m_dim_id_prim_M</span><span class="p">];</span>
<span class="w">    </span><span class="kt">int64_t</span><span class="w"> </span><span class="n">l_stride_out</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_strides_out</span><span class="p">[</span><span class="n">m_dim_id_prim_M</span><span class="p">];</span>
<span class="w">    </span><span class="c1">// set transpose flag to true if the strides are different</span>
<span class="w">    </span><span class="n">m_transpose_output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">l_stride_in0</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">l_stride_out</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">else</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// idk if we can check for transposition without M</span>
<span class="w">    </span><span class="n">m_transpose_output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">/////////////////////////////////////////////////////////////////////</span>
<span class="c1">// Adjust strides based on primitive type and transposition</span>
<span class="c1">/////////////////////////////////////////////////////////////////////</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">prim_main</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">ptype_t</span><span class="o">::</span><span class="n">identity</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">m_transpose_output</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">m_adjusted_stride_in0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_strides_in0</span><span class="p">[</span><span class="n">m_dim_id_prim_N</span><span class="p">];</span>
<span class="w">        </span><span class="n">m_adjusted_stride_in1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="n">m_adjusted_stride_out</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_strides_out</span><span class="p">[</span><span class="n">m_dim_id_prim_N</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">m_adjusted_stride_in0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_strides_in0</span><span class="p">[</span><span class="n">m_dim_id_prim_N</span><span class="p">];</span>
<span class="w">        </span><span class="n">m_adjusted_stride_in1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="n">m_adjusted_stride_out</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_strides_out</span><span class="p">[</span><span class="n">m_dim_id_prim_M</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
<span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">prim_main</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">ptype_t</span><span class="o">::</span><span class="n">add</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">prim_main</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">ptype_t</span><span class="o">::</span><span class="n">sub</span><span class="w"> </span><span class="o">||</span>
<span class="w">         </span><span class="n">prim_main</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">ptype_t</span><span class="o">::</span><span class="n">mul</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">prim_main</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">ptype_t</span><span class="o">::</span><span class="n">div</span><span class="w"> </span><span class="o">||</span>
<span class="w">         </span><span class="n">prim_main</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">ptype_t</span><span class="o">::</span><span class="n">min</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">prim_main</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">ptype_t</span><span class="o">::</span><span class="n">max</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">m_adjusted_stride_in0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_strides_in0</span><span class="p">[</span><span class="n">m_dim_id_prim_N</span><span class="p">];</span>
<span class="w">    </span><span class="n">m_adjusted_stride_in1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_strides_in1</span><span class="p">[</span><span class="n">m_dim_id_prim_N</span><span class="p">];</span>
<span class="w">    </span><span class="n">m_adjusted_stride_out</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_strides_out</span><span class="p">[</span><span class="n">m_dim_id_prim_N</span><span class="p">];</span>
<span class="p">}</span>
<span class="k">else</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// GEMM &amp; BRGEMM</span>
<span class="w">    </span><span class="n">m_adjusted_stride_in0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_strides_in0</span><span class="p">[</span><span class="n">m_dim_id_prim_K</span><span class="p">];</span>
<span class="w">    </span><span class="n">m_adjusted_stride_in1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_strides_in1</span><span class="p">[</span><span class="n">m_dim_id_prim_N</span><span class="p">];</span>
<span class="w">    </span><span class="n">m_adjusted_stride_out</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_strides_out</span><span class="p">[</span><span class="n">m_dim_id_prim_N</span><span class="p">];</span>
<span class="p">}</span>
<span class="n">m_adjusted_br_size_A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_dim_id_prim_BR</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">-1</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">m_strides_in0</span><span class="p">[</span><span class="n">m_dim_id_prim_BR</span><span class="p">]</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="n">m_adjusted_br_size_B</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_dim_id_prim_BR</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">-1</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">m_strides_in1</span><span class="p">[</span><span class="n">m_dim_id_prim_BR</span><span class="p">]</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
</pre></div>
</div>
</div>
<p>Lastly, we need to generate the kernels. As the process is very similar for most kernels, we will provide only a brief code snippet here.</p>
<div class="literal-block-wrapper docutils container" id="id10">
<div class="code-block-caption"><span class="caption-text">First touch, gemm and brgemm kernel generation</span><a class="headerlink" href="#id10" title="Link to this code"></a></div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">prim_first_touch</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">ptype_t</span><span class="o">::</span><span class="n">none</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// no transposition</span>
<span class="w">    </span><span class="n">m_unary_first_touch</span><span class="p">.</span><span class="n">generate</span><span class="p">(</span><span class="n">m_dim_sizes</span><span class="p">[</span><span class="n">m_dim_id_prim_M</span><span class="p">],</span>
<span class="w">                                 </span><span class="n">m_dim_sizes</span><span class="p">[</span><span class="n">m_dim_id_prim_N</span><span class="p">],</span>
<span class="w">                                 </span><span class="mi">0</span><span class="p">,</span>
<span class="w">                                 </span><span class="n">dtype</span><span class="p">,</span>
<span class="w">                                 </span><span class="n">prim_first_touch</span><span class="p">);</span>
<span class="w">    </span><span class="n">m_kernel_first_touch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_unary_first_touch</span><span class="p">.</span><span class="n">get_kernel</span><span class="p">();</span>
<span class="p">}</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">prim_main</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">ptype_t</span><span class="o">::</span><span class="n">gemm</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// no transposition</span>
<span class="w">    </span><span class="n">m_brgemm_main</span><span class="p">.</span><span class="n">generate</span><span class="p">(</span><span class="n">m_dim_sizes</span><span class="p">[</span><span class="n">m_dim_id_prim_M</span><span class="p">],</span>
<span class="w">                           </span><span class="n">m_dim_sizes</span><span class="p">[</span><span class="n">m_dim_id_prim_N</span><span class="p">],</span>
<span class="w">                           </span><span class="n">m_dim_sizes</span><span class="p">[</span><span class="n">m_dim_id_prim_K</span><span class="p">],</span>
<span class="w">                           </span><span class="mi">1</span><span class="p">,</span>
<span class="w">                           </span><span class="mi">0</span><span class="p">,</span>
<span class="w">                           </span><span class="mi">0</span><span class="p">,</span>
<span class="w">                           </span><span class="mi">0</span><span class="p">,</span>
<span class="w">                           </span><span class="n">dtype</span><span class="p">);</span>
<span class="w">    </span><span class="n">m_kernel_gemm_main</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_brgemm_main</span><span class="p">.</span><span class="n">get_kernel</span><span class="p">();</span>
<span class="p">}</span>
<span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">prim_main</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">ptype_t</span><span class="o">::</span><span class="n">brgemm</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// no transposition</span>
<span class="w">    </span><span class="n">m_brgemm_main</span><span class="p">.</span><span class="n">generate</span><span class="p">(</span><span class="n">m_dim_sizes</span><span class="p">[</span><span class="n">m_dim_id_prim_M</span><span class="p">],</span>
<span class="w">                           </span><span class="n">m_dim_sizes</span><span class="p">[</span><span class="n">m_dim_id_prim_N</span><span class="p">],</span>
<span class="w">                           </span><span class="n">m_dim_sizes</span><span class="p">[</span><span class="n">m_dim_id_prim_K</span><span class="p">],</span>
<span class="w">                           </span><span class="n">m_dim_sizes</span><span class="p">[</span><span class="n">m_dim_id_prim_BR</span><span class="p">],</span>
<span class="w">                           </span><span class="mi">0</span><span class="p">,</span>
<span class="w">                           </span><span class="mi">0</span><span class="p">,</span>
<span class="w">                           </span><span class="mi">0</span><span class="p">,</span>
<span class="w">                           </span><span class="n">dtype</span><span class="p">);</span>
<span class="w">    </span><span class="n">m_kernel_gemm_main</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_brgemm_main</span><span class="p">.</span><span class="n">get_kernel</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</section>
<section id="recursive-loops-over-primitives">
<h2>5.2 Recursive Loops over Primitives<a class="headerlink" href="#recursive-loops-over-primitives" title="Link to this heading"></a></h2>
<p>After generating the kernels, we needed to implement a function to execute the tensor operation.
The entry point is an <code class="docutils literal notranslate"><span class="pre">execute</span></code> function that takes the pointers to our matrices and passes
them to our <code class="docutils literal notranslate"><span class="pre">execute_iter</span></code> function.</p>
<div class="literal-block-wrapper docutils container" id="id11">
<div class="code-block-caption"><span class="caption-text">Entry point function: execute</span><a class="headerlink" href="#id11" title="Link to this code"></a></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">mini_jit::TensorOperation::execute</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="k">const</span><span class="o">*</span><span class="w"> </span><span class="n">tensor_in0</span><span class="p">,</span>
<span class="w">                                        </span><span class="kt">void</span><span class="w"> </span><span class="k">const</span><span class="o">*</span><span class="w"> </span><span class="n">tensor_in1</span><span class="p">,</span>
<span class="w">                                        </span><span class="kt">void</span><span class="o">*</span><span class="w">       </span><span class="n">tensor_out</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">m_has_been_setup</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cerr</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;TensorOperation has not been setup. Call setup() before execute().&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">        </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">ptr_in0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">char</span><span class="w"> </span><span class="k">const</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">tensor_in0</span><span class="p">);</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">ptr_in1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">char</span><span class="w"> </span><span class="k">const</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">tensor_in1</span><span class="p">);</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">ptr_out</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">tensor_out</span><span class="p">);</span>

<span class="w">    </span><span class="n">execute_iter</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span>
<span class="w">                 </span><span class="n">ptr_in0</span><span class="p">,</span>
<span class="w">                 </span><span class="n">ptr_in1</span><span class="p">,</span>
<span class="w">                 </span><span class="n">ptr_out</span><span class="p">,</span>
<span class="w">                 </span><span class="nb">true</span><span class="p">,</span><span class="n">y</span>
<span class="w">                 </span><span class="nb">true</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<p>The ‘real’ execution happens in the <code class="docutils literal notranslate"><span class="pre">execute_iter</span></code> function.</p>
<p>First, we determine the strides, retrieve the size of the current dimension and start a loop over the current dimension.</p>
<div class="literal-block-wrapper docutils container" id="id12">
<div class="code-block-caption"><span class="caption-text">Determining the strides and looping over the current dimension size</span><a class="headerlink" href="#id12" title="Link to this code"></a></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">mini_jit::TensorOperation::execute_iter</span><span class="p">(</span><span class="kt">int64_t</span><span class="w">     </span><span class="n">id_loop</span><span class="p">,</span>
<span class="w">                                             </span><span class="kt">char</span><span class="w"> </span><span class="k">const</span><span class="o">*</span><span class="w"> </span><span class="n">ptr_in0</span><span class="p">,</span>
<span class="w">                                             </span><span class="kt">char</span><span class="w"> </span><span class="k">const</span><span class="o">*</span><span class="w"> </span><span class="n">ptr_in1</span><span class="p">,</span>
<span class="w">                                             </span><span class="kt">char</span><span class="o">*</span><span class="w">       </span><span class="n">ptr_out</span><span class="p">,</span>
<span class="w">                                             </span><span class="kt">bool</span><span class="w">        </span><span class="n">first_access</span><span class="p">,</span>
<span class="w">                                             </span><span class="kt">bool</span><span class="w">        </span><span class="n">last_access</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// there is only one iteration if the dimension is the first primitive</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">int64_t</span><span class="w"> </span><span class="n">l_size</span><span class="w">       </span><span class="o">=</span><span class="w"> </span><span class="n">id_loop</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">m_id_first_primitive_loop</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">m_dim_sizes</span><span class="p">[</span><span class="n">id_loop</span><span class="p">]</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">int64_t</span><span class="w"> </span><span class="n">dtype_sz</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="n">dtype_size</span><span class="p">();</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">int64_t</span><span class="w"> </span><span class="n">l_stride_in0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_strides_in0</span><span class="p">[</span><span class="n">id_loop</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">dtype_sz</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">int64_t</span><span class="w"> </span><span class="n">l_stride_in1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_strides_in1</span><span class="p">[</span><span class="n">id_loop</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">dtype_sz</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">int64_t</span><span class="w"> </span><span class="n">l_stride_out</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_strides_out</span><span class="p">[</span><span class="n">id_loop</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">dtype_sz</span><span class="p">;</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int64_t</span><span class="w"> </span><span class="n">l_iter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">l_iter</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">l_size</span><span class="p">;</span><span class="w"> </span><span class="n">l_iter</span><span class="o">++</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="p">[</span><span class="n">See</span><span class="w"> </span><span class="n">code</span><span class="w"> </span><span class="n">snippets</span><span class="w"> </span><span class="n">below</span><span class="p">]</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<p>Inside the loop, we first check if the current iteration is the first or last access to the block in the output matrix.</p>
<div class="literal-block-wrapper docutils container" id="id13">
<div class="code-block-caption"><span class="caption-text">Determining if the current iteration is the first or last access to the block in the output matrix</span><a class="headerlink" href="#id13" title="Link to this code"></a></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">is_first</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">first_access</span><span class="p">;</span>
<span class="kt">bool</span><span class="w"> </span><span class="n">is_last</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">last_access</span><span class="p">;</span>
<span class="c1">// if the size is 1, it is always the first and last access</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">l_size</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">m_dim_types</span><span class="p">[</span><span class="n">id_loop</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">dim_t</span><span class="o">::</span><span class="n">k</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">is_first</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">first_access</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">l_iter</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="n">is_last</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">last_access</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">l_iter</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">m_dim_sizes</span><span class="p">[</span><span class="n">id_loop</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<p>Next, we adjust the pointers to the correct blocks of the matrices and execute the kernels if necessary.
In the case that the current dimension, is a sequential dimension, we recursively call the <code class="docutils literal notranslate"><span class="pre">execute_iter</span></code> function again in order to go deeper into the loop structure.</p>
<div class="literal-block-wrapper docutils container" id="id14">
<div class="code-block-caption"><span class="caption-text">Stride adjustment and recursive call to execute_iter</span><a class="headerlink" href="#id14" title="Link to this code"></a></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">char</span><span class="w"> </span><span class="k">const</span><span class="o">*</span><span class="w"> </span><span class="n">sub_ptr_in0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ptr_in0</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">l_iter</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">l_stride_in0</span><span class="p">;</span>
<span class="kt">char</span><span class="w"> </span><span class="k">const</span><span class="o">*</span><span class="w"> </span><span class="n">sub_ptr_in1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ptr_in1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">l_iter</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">l_stride_in1</span><span class="p">;</span>
<span class="kt">char</span><span class="o">*</span><span class="w">       </span><span class="n">sub_ptr_out</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ptr_out</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">l_iter</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">l_stride_out</span><span class="p">;</span>

<span class="c1">// Recursive Call</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">id_loop</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">m_id_first_primitive_loop</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">execute_iter</span><span class="p">(</span><span class="n">id_loop</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">                    </span><span class="n">sub_ptr_in0</span><span class="p">,</span>
<span class="w">                    </span><span class="n">sub_ptr_in1</span><span class="p">,</span>
<span class="w">                    </span><span class="n">sub_ptr_out</span><span class="p">,</span>
<span class="w">                    </span><span class="n">is_first</span><span class="p">,</span>
<span class="w">                    </span><span class="n">is_last</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<p>However, in case the current dimension is the last sequential dimension and the next one the first primitive dimension, we need to execute the actual kernels. Depending on the <code class="docutils literal notranslate"><span class="pre">is_first</span></code> and <code class="docutils literal notranslate"><span class="pre">is_last</span></code> variables, the first and last touch kernels are also executed.</p>
<div class="literal-block-wrapper docutils container" id="id15">
<div class="code-block-caption"><span class="caption-text">Executing the kernels</span><a class="headerlink" href="#id15" title="Link to this code"></a></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">else</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">is_first</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">execute_kernel_first_touch</span><span class="p">(</span><span class="n">sub_ptr_out</span><span class="p">,</span>
<span class="w">                                    </span><span class="n">m_adjusted_stride_out</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">execute_kernel_main</span><span class="p">(</span><span class="n">sub_ptr_in0</span><span class="p">,</span>
<span class="w">                        </span><span class="n">sub_ptr_in1</span><span class="p">,</span>
<span class="w">                        </span><span class="n">sub_ptr_out</span><span class="p">,</span>
<span class="w">                        </span><span class="n">m_adjusted_stride_in0</span><span class="p">,</span>
<span class="w">                        </span><span class="n">m_adjusted_stride_in1</span><span class="p">,</span>
<span class="w">                        </span><span class="n">m_adjusted_stride_out</span><span class="p">,</span>
<span class="w">                        </span><span class="n">m_adjusted_br_size_A</span><span class="p">,</span>
<span class="w">                        </span><span class="n">m_adjusted_br_size_B</span><span class="p">);</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">is_last</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">execute_kernel_last_touch</span><span class="p">(</span><span class="n">sub_ptr_out</span><span class="p">,</span>
<span class="w">                                    </span><span class="n">m_adjusted_stride_out</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</section>
<section id="performance-benchmarking">
<span id="sequential-benchmarking"></span><h2>5.3 Performance Benchmarking<a class="headerlink" href="#performance-benchmarking" title="Link to this heading"></a></h2>
<p>To test the performance of our at runtime constructed kernels and to see if everything works seamlessly together,
we were performing some reference benchmarks.</p>
<p>For this, we were given a number of configuration parameters:</p>
<table class="docutils align-default" id="id16">
<caption><span class="caption-text">Benchmark Configuration</span><a class="headerlink" href="#id16" title="Link to this table"></a></caption>
<colgroup>
<col style="width: 25.0%" />
<col style="width: 25.0%" />
<col style="width: 25.0%" />
<col style="width: 25.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Variable</p></th>
<th class="head"><p>1st Value</p></th>
<th class="head"><p>2nd Value</p></th>
<th class="head"><p>3rd Value</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><strong>dtype</strong></p></td>
<td><p>FP32</p></td>
<td><p>FP32</p></td>
<td><p>FP32</p></td>
</tr>
<tr class="row-odd"><td><p><strong>prim_first_touch</strong></p></td>
<td><p>None</p></td>
<td><p>None</p></td>
<td><p>Zero</p></td>
</tr>
<tr class="row-even"><td><p><strong>prim_main</strong></p></td>
<td><p>GEMM</p></td>
<td><p>BRGEMM</p></td>
<td><p>BRGEMM</p></td>
</tr>
<tr class="row-odd"><td><p><strong>prim_last_touch</strong></p></td>
<td><p>None</p></td>
<td><p>None</p></td>
<td><p>ReLU</p></td>
</tr>
<tr class="row-even"><td><p><strong>dim_types</strong></p></td>
<td><p>(M, N, K, M, N, K)</p></td>
<td><p>(M, N, K, M, N, K)</p></td>
<td><p>(M, N, K, M, N, K)</p></td>
</tr>
<tr class="row-odd"><td><p><strong>exec_types</strong></p></td>
<td><p>(Seq, Seq, Seq, Prim, Prim, Prim)</p></td>
<td><p>(Seq, Seq, Prim, Prim, Prim, Prim)</p></td>
<td><p>(Seq, Seq, Prim, Prim, Prim, Prim)</p></td>
</tr>
<tr class="row-even"><td><p><strong>dim_sizes</strong></p></td>
<td><p>(32, 32, 8, 32, 32, 32)</p></td>
<td><p>(32, 32, 8, 32, 32, 32)</p></td>
<td><p>(32, 32, 8, 32, 32, 32)</p></td>
</tr>
<tr class="row-odd"><td><p><strong>strides_in0</strong></p></td>
<td><p>(8192, 0, 1024, 1, 0, 32)</p></td>
<td><p>(8192, 0, 1024, 1, 0, 32)</p></td>
<td><p>(8192, 0, 1024, 1, 0, 32)</p></td>
</tr>
<tr class="row-even"><td><p><strong>strides_in1</strong></p></td>
<td><p>(0, 8192, 1024, 0, 32, 1)</p></td>
<td><p>(0, 8192, 1024, 0, 32, 1)</p></td>
<td><p>(0, 8192, 1024, 0, 32, 1)</p></td>
</tr>
<tr class="row-odd"><td><p><strong>strides_out</strong></p></td>
<td><p>(32768, 1024, 0, 1, 32, 0)</p></td>
<td><p>(32768, 1024, 0, 1, 32, 0)</p></td>
<td><p>(32768, 1024, 0, 1, 32, 0)</p></td>
</tr>
</tbody>
</table>
<p>When benchmarking the configurations we achieved the following performance in <code class="docutils literal notranslate"><span class="pre">GFLOPs</span></code>:</p>
<div class="literal-block-wrapper docutils container" id="id17">
<div class="code-block-caption"><span class="caption-text"><code class="docutils literal notranslate"><span class="pre">GFLOP</span></code> performance of the given configurations</span><a class="headerlink" href="#id17" title="Link to this code"></a></div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Running TensorOperationBench benchmark #1
Total time (s):                  3.0052
Total reps:                      398
Total floating point operations: 213674622976
Estimated GFLOPS/sec:            71.1017
--------------------------------------------------
Running TensorOperationBench benchmark #2
Total time (s):                  3.0062
Total reps:                      413
Total floating point operations: 221727686656
Estimated GFLOPS/sec:            73.7568
--------------------------------------------------
Running TensorOperationBench benchmark #3
Total time (s):                  3.00738
Total reps:                      400
Total floating point operations: 214748364800
Estimated GFLOPS/sec:            71.4071
--------------------------------------------------
</pre></div>
</div>
</div>
<p>The results show that we achieve between <code class="docutils literal notranslate"><span class="pre">71-73</span> <span class="pre">GFLOPs</span></code> for all our executions.
These results are somewhat consistent with calling the kernels themselves independently.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Since the submission we made some minor changes to our implementation.
To improve performance, we decided to enhance our <code class="docutils literal notranslate"><span class="pre">matmul_m_n_k</span></code> implementation.
Specifically, the matmul kernel now computes blocks with a size of <code class="docutils literal notranslate"><span class="pre">16x4</span></code> instead of <code class="docutils literal notranslate"><span class="pre">8x4</span></code>.
This helped us increase the results from <code class="docutils literal notranslate"><span class="pre">71-73</span> <span class="pre">GFLOPs</span></code> to around <code class="docutils literal notranslate"><span class="pre">90-91</span> <span class="pre">GFLOPs</span></code>.</p>
</div>
<div class="literal-block-wrapper docutils container" id="id18">
<div class="code-block-caption"><span class="caption-text"><code class="docutils literal notranslate"><span class="pre">GFLOP</span></code> performance of the given configurations using the enhanced <code class="docutils literal notranslate"><span class="pre">matmul</span></code> kernel</span><a class="headerlink" href="#id18" title="Link to this code"></a></div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Running TensorOperationBench benchmark #1
Total time (s):                  3.00343
Total reps:                      510
Total floating point operations: 273804165120
Estimated GFLOPS/sec:            91.1637
--------------------------------------------------
Running TensorOperationBench benchmark #2
Total time (s):                  3.00537
Total reps:                      514
Total floating point operations: 275951648768
Estimated GFLOPS/sec:            91.8195
--------------------------------------------------
Running TensorOperationBench benchmark #3
Total time (s):                  3.00405
Total reps:                      505
Total floating point operations: 271119810560
Estimated GFLOPS/sec:            90.2515
--------------------------------------------------
</pre></div>
</div>
</div>
</section>
<section id="shared-memory-parallelization">
<span id="id1"></span><h2>5.4 Shared Memory Parallelization<a class="headerlink" href="#shared-memory-parallelization" title="Link to this heading"></a></h2>
<p>To enable the execution of shared loops, we needed to make a few adjustments to our <code class="docutils literal notranslate"><span class="pre">setup</span></code> code:</p>
<div class="literal-block-wrapper docutils container" id="id19">
<div class="code-block-caption"><span class="caption-text">Gathering shared loop IDs and dimension sizes</span><a class="headerlink" href="#id19" title="Link to this code"></a></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">/////////////////////////////////////////////////////////////////////</span>
<span class="c1">// Find SHARED dimensions in exec types</span>
<span class="c1">/////////////////////////////////////////////////////////////////////</span>
<span class="n">m_shared_loop_ids</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
<span class="n">m_shared_loop_sizes</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">m_exec_types</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">m_exec_types</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">exec_t</span><span class="o">::</span><span class="n">shared</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">m_shared_loop_ids</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="w">        </span><span class="n">m_shared_loop_sizes</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">m_dim_sizes</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="id20">
<div class="code-block-caption"><span class="caption-text">Reading the shared dimension IDs</span><a class="headerlink" href="#id20" title="Link to this code"></a></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">/////////////////////////////////////////////////////////////////////</span>
<span class="c1">// Read SEQ and SHARED dimensions using dim types</span>
<span class="c1">/////////////////////////////////////////////////////////////////////</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">m_dim_types</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">m_exec_types</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">exec_t</span><span class="o">::</span><span class="n">seq</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">m_dim_types</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">dim_t</span><span class="o">::</span><span class="n">m</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">m_dim_id_seq_M</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">m_dim_types</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">dim_t</span><span class="o">::</span><span class="n">n</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">m_dim_id_seq_N</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">m_dim_types</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">dim_t</span><span class="o">::</span><span class="n">k</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">m_dim_id_seq_K</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">m_exec_types</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">exec_t</span><span class="o">::</span><span class="n">shared</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">m_dim_types</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">dim_t</span><span class="o">::</span><span class="n">m</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">m_dim_id_sha_M</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">            </span><span class="n">m_num_parallel_loops</span><span class="o">++</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">m_dim_types</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">dim_t</span><span class="o">::</span><span class="n">n</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">m_dim_id_sha_N</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">            </span><span class="n">m_num_parallel_loops</span><span class="o">++</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<p>In our execute function we needed to add a check if our <code class="docutils literal notranslate"><span class="pre">m_num_parallel_loops</span></code> variable would be greater
than zero. If this was the case we would then execute our <code class="docutils literal notranslate"><span class="pre">execute_iter_parallel</span></code> function:</p>
<div class="literal-block-wrapper docutils container" id="id21">
<div class="code-block-caption"><span class="caption-text">Updated execute function</span><a class="headerlink" href="#id21" title="Link to this code"></a></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">mini_jit::TensorOperation::execute</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="k">const</span><span class="o">*</span><span class="w"> </span><span class="n">tensor_in0</span><span class="p">,</span>
<span class="w">                                        </span><span class="kt">void</span><span class="w"> </span><span class="k">const</span><span class="o">*</span><span class="w"> </span><span class="n">tensor_in1</span><span class="p">,</span>
<span class="w">                                        </span><span class="kt">void</span><span class="o">*</span><span class="w">       </span><span class="n">tensor_out</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">m_has_been_setup</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cerr</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;TensorOperation has not been setup. Call setup() before execute().&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">        </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">ptr_in0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">char</span><span class="w"> </span><span class="k">const</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">tensor_in0</span><span class="p">);</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">ptr_in1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">char</span><span class="w"> </span><span class="k">const</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">tensor_in1</span><span class="p">);</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">ptr_out</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">tensor_out</span><span class="p">);</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">m_num_parallel_loops</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// No shared loops, execute sequentially</span>
<span class="w">        </span><span class="n">execute_iter</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span>
<span class="w">                    </span><span class="n">ptr_in0</span><span class="p">,</span>
<span class="w">                    </span><span class="n">ptr_in1</span><span class="p">,</span>
<span class="w">                    </span><span class="n">ptr_out</span><span class="p">,</span>
<span class="w">                    </span><span class="nb">true</span><span class="p">,</span>
<span class="w">                    </span><span class="nb">true</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Shared loops, execute in parallel</span>
<span class="w">        </span><span class="n">execute_iter_parallel</span><span class="p">(</span><span class="n">ptr_in0</span><span class="p">,</span>
<span class="w">                            </span><span class="n">ptr_in1</span><span class="p">,</span>
<span class="w">                            </span><span class="n">ptr_out</span><span class="p">,</span>
<span class="w">                            </span><span class="nb">true</span><span class="p">,</span>
<span class="w">                            </span><span class="nb">true</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<p>Inside the <code class="docutils literal notranslate"><span class="pre">execute_iter_parallel</span></code>, we first multiply the shared loop sizes to get the total number of iterations.
The idea is to get a flat iteration space that can be used to parallelize over.</p>
<div class="literal-block-wrapper docutils container" id="id22">
<div class="code-block-caption"><span class="caption-text">multiply shared loop sizes to get the total number of iterations</span><a class="headerlink" href="#id22" title="Link to this code"></a></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Compute total number of iterations over shared loops</span>
<span class="kt">int64_t</span><span class="w"> </span><span class="n">l_size_parallel_loops</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">current_loop_size</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">m_shared_loop_sizes</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">l_size_parallel_loops</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">current_loop_size</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int64_t</span><span class="w"> </span><span class="n">l_first_id_loop</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">m_id_first_seq_loop</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">-1</span><span class="p">)</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">m_id_first_seq_loop</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">m_id_first_primitive_loop</span><span class="p">;</span>
</pre></div>
</div>
</div>
<p>We unflatten the OpenMP iteration index <code class="docutils literal notranslate"><span class="pre">l_it_all</span></code> into a set of loop indices, one for each shared loop dimension.
These indices are then used to compute the offsets for the <code class="docutils literal notranslate"><span class="pre">in0</span></code>, <code class="docutils literal notranslate"><span class="pre">in1</span></code>, and <code class="docutils literal notranslate"><span class="pre">out</span></code> tensors:</p>
<div class="literal-block-wrapper docutils container" id="id23">
<div class="code-block-caption"><span class="caption-text">Calculating the tensor offsets</span><a class="headerlink" href="#id23" title="Link to this code"></a></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma omp parallel for</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int64_t</span><span class="w"> </span><span class="n">l_it_all</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">l_it_all</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">l_size_parallel_loops</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">l_it_all</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Unflatten l_it_all into loop indices</span>
<span class="w">    </span><span class="kt">int64_t</span><span class="w">              </span><span class="n">remainder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">l_it_all</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">loop_indices</span><span class="p">(</span><span class="n">m_shared_loop_ids</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int64_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_shared_loop_ids</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="o">--</span><span class="n">i</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">loop_indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">remainder</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">m_shared_loop_sizes</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">        </span><span class="n">remainder</span><span class="w"> </span><span class="o">/=</span><span class="w"> </span><span class="n">m_shared_loop_sizes</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Compute pointer offsets using strides and loop indices</span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="k">const</span><span class="o">*</span><span class="w"> </span><span class="n">sub_ptr_in0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ptr_in0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="k">const</span><span class="o">*</span><span class="w"> </span><span class="n">sub_ptr_in1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ptr_in1</span><span class="p">;</span>
<span class="w">    </span><span class="kt">char</span><span class="o">*</span><span class="w">       </span><span class="n">sub_ptr_out</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ptr_out</span><span class="p">;</span>

<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">int64_t</span><span class="w"> </span><span class="n">dtype_sz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dtype_size</span><span class="p">();</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">m_shared_loop_ids</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="kt">int64_t</span><span class="w"> </span><span class="n">dim_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_shared_loop_ids</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="kt">int64_t</span><span class="w"> </span><span class="n">idx</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">loop_indices</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

<span class="w">        </span><span class="n">sub_ptr_in0</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">m_strides_in0</span><span class="p">[</span><span class="n">dim_id</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">dtype_sz</span><span class="p">;</span>
<span class="w">        </span><span class="n">sub_ptr_in1</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">m_strides_in1</span><span class="p">[</span><span class="n">dim_id</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">dtype_sz</span><span class="p">;</span>
<span class="w">        </span><span class="n">sub_ptr_out</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">m_strides_out</span><span class="p">[</span><span class="n">dim_id</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">dtype_sz</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
</pre></div>
</div>
</div>
<p>Here we are calculating the offset for the current thread.
Every shared loop contributes to the calculation with its corresponding stride.</p>
<p>Lastly, we call our <code class="docutils literal notranslate"><span class="pre">execute_iter</span></code> function.</p>
<div class="literal-block-wrapper docutils container" id="id24">
<div class="code-block-caption"><span class="caption-text">Executing the remaining loops with execute_iter</span><a class="headerlink" href="#id24" title="Link to this code"></a></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Call remaining loops</span>
<span class="n">execute_iter</span><span class="p">(</span><span class="n">l_first_id_loop</span><span class="p">,</span>
<span class="w">                </span><span class="n">sub_ptr_in0</span><span class="p">,</span>
<span class="w">                </span><span class="n">sub_ptr_in1</span><span class="p">,</span>
<span class="w">                </span><span class="n">sub_ptr_out</span><span class="p">,</span>
<span class="w">                </span><span class="n">first_access</span><span class="p">,</span>
<span class="w">                </span><span class="n">last_access</span><span class="p">);</span>
</pre></div>
</div>
</div>
<p>After having implemented the shared loop parallelization, we benchmarked the configurations from the <a class="reference internal" href="#sequential-benchmarking"><span class="std std-ref">sequential execution</span></a> task again.
To enable multithreading, we called the executable with <code class="docutils literal notranslate"><span class="pre">OMP_NUM_THREADS=4</span></code>.</p>
<div class="literal-block-wrapper docutils container" id="id25">
<div class="code-block-caption"><span class="caption-text"><code class="docutils literal notranslate"><span class="pre">GFLOP</span></code> performance for <code class="docutils literal notranslate"><span class="pre">4</span> <span class="pre">shared</span></code> loop execution</span><a class="headerlink" href="#id25" title="Link to this code"></a></div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span>Running SharedTensorOperationBench benchmark #1
<span class="linenos"> 2</span>Total time (s):                  3.00107
<span class="linenos"> 3</span>Total reps:                      1993
<span class="linenos"> 4</span>Total floating point operations: 1069983727616
<span class="linenos"> 5</span>Estimated GFLOPS/sec:            356.534
<span class="linenos"> 6</span>--------------------------------------------------
<span class="linenos"> 7</span>Running SharedTensorOperationBench benchmark #2
<span class="linenos"> 8</span>Total time (s):                  3.00002
<span class="linenos"> 9</span>Total reps:                      2168
<span class="linenos">10</span>Total floating point operations: 1163936137216
<span class="linenos">11</span>Estimated GFLOPS/sec:            387.976
<span class="linenos">12</span>--------------------------------------------------
<span class="linenos">13</span>Running SharedTensorOperationBench benchmark #3
<span class="linenos">14</span>Total time (s):                  3.00093
<span class="linenos">15</span>Total reps:                      2126
<span class="linenos">16</span>Total floating point operations: 1141387558912
<span class="linenos">17</span>Estimated GFLOPS/sec:            380.345
<span class="linenos">18</span>--------------------------------------------------
</pre></div>
</div>
</div>
<p>With the parallelization we achieved about <code class="docutils literal notranslate"><span class="pre">360</span> <span class="pre">-</span> <span class="pre">390</span> <span class="pre">GFLOPs</span></code>.</p>
</section>
<section id="optimization-passes">
<span id="id2"></span><h2>5.5 Optimization Passes<a class="headerlink" href="#optimization-passes" title="Link to this heading"></a></h2>
<p>To lay the foundation for our Optimizer, we first decided to implement a Dimension <code class="docutils literal notranslate"><span class="pre">struct</span></code> that wraps all information on a dimension.</p>
<div class="literal-block-wrapper docutils container" id="id26">
<div class="code-block-caption"><span class="caption-text">Dimension struct</span><a class="headerlink" href="#id26" title="Link to this code"></a></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm">* @brief The Dimension struct represents a dimension in a tensor operation.</span>
<span class="cm">* It contains information about the type of dimension (M, N, K), execution type (Prim, Seq, Shared),</span>
<span class="cm">* size, and strides for the input and output tensors.</span>
<span class="cm">*/</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">Dimension</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">//! Type of the dimension (M, N, K)</span>
<span class="w">    </span><span class="n">dim_t</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dim_t</span><span class="o">::</span><span class="n">m</span><span class="p">;</span>
<span class="w">    </span><span class="c1">//! Execution type (Prim, Seq, Shared, ...)</span>
<span class="w">    </span><span class="n">exec_t</span><span class="w"> </span><span class="n">exec_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">exec_t</span><span class="o">::</span><span class="n">undefined</span><span class="p">;</span>
<span class="w">    </span><span class="c1">//! Dimension size</span>
<span class="w">    </span><span class="kt">int64_t</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="c1">//! Stride in the first input tensor</span>
<span class="w">    </span><span class="kt">int64_t</span><span class="w"> </span><span class="n">stride_in0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="c1">//! Stride in the second input tensor</span>
<span class="w">    </span><span class="kt">int64_t</span><span class="w"> </span><span class="n">stride_in1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="c1">//! Stride in the output tensor</span>
<span class="w">    </span><span class="kt">int64_t</span><span class="w"> </span><span class="n">stride_out</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/**</span>
<span class="cm">        * @brief Construct a new Dimension object.</span>
<span class="cm">        *</span>
<span class="cm">        * @param type Type of the dimension (M, N, K).</span>
<span class="cm">        * @param exec_type Execution type (Prim, Seq, Shared, ...).</span>
<span class="cm">        * @param size Size of the dimension.</span>
<span class="cm">        * @param stride_in0 Stride in the first input tensor.</span>
<span class="cm">        * @param stride_in1 Stride in the second input tensor.</span>
<span class="cm">        * @param stride_out Stride in the output tensor.</span>
<span class="cm">        */</span>
<span class="w">    </span><span class="n">Dimension</span><span class="p">(</span><span class="n">dim_t</span><span class="w">   </span><span class="n">type</span><span class="p">,</span>
<span class="w">                </span><span class="n">exec_t</span><span class="w">  </span><span class="n">exec_type</span><span class="p">,</span>
<span class="w">                </span><span class="kt">int64_t</span><span class="w"> </span><span class="n">size</span><span class="p">,</span>
<span class="w">                </span><span class="kt">int64_t</span><span class="w"> </span><span class="n">stride_in0</span><span class="p">,</span>
<span class="w">                </span><span class="kt">int64_t</span><span class="w"> </span><span class="n">stride_in1</span><span class="p">,</span>
<span class="w">                </span><span class="kt">int64_t</span><span class="w"> </span><span class="n">stride_out</span><span class="p">)</span>
<span class="w">        </span><span class="o">:</span><span class="w"> </span><span class="n">type</span><span class="p">(</span><span class="n">type</span><span class="p">),</span>
<span class="w">            </span><span class="n">exec_type</span><span class="p">(</span><span class="n">exec_type</span><span class="p">),</span>
<span class="w">            </span><span class="n">size</span><span class="p">(</span><span class="n">size</span><span class="p">),</span>
<span class="w">            </span><span class="n">stride_in0</span><span class="p">(</span><span class="n">stride_in0</span><span class="p">),</span>
<span class="w">            </span><span class="n">stride_in1</span><span class="p">(</span><span class="n">stride_in1</span><span class="p">),</span>
<span class="w">            </span><span class="n">stride_out</span><span class="p">(</span><span class="n">stride_out</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">size</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">throw</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">invalid_argument</span><span class="p">(</span><span class="s">&quot;Dimension size needs to be greater than 0&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<p>This method seemed simpler to us in comparison to accessing and reordering all information of a Dimension using multiple vectors that only store a single property each.</p>
<section id="primitive-identification">
<h3>5.5.1 Primitive Identification<a class="headerlink" href="#primitive-identification" title="Link to this heading"></a></h3>
<p>The first optimization pass which we implemented was the primitive identification.
This optimization is useful in cases where only sequential and shared loops are given.</p>
<p>First we need to check whether we are optimizing a unary operation (identity, permutation), a binary operation (Add, Sub, Mul; See <a class="reference internal" href="07_individual_phase.html#binary-primitives"><span class="std std-ref">7.3.2 Binary Primitives</span></a>) or a ternary operation (GEMM, BRGEMM).</p>
<div class="literal-block-wrapper docutils container" id="id27">
<div class="code-block-caption"><span class="caption-text">Checking for the existence of C and K dimensions</span><a class="headerlink" href="#id27" title="Link to this code"></a></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="n">l_has_c_dim</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">any_of</span><span class="p">(</span><span class="n">dimensions</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">dimensions</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="p">[](</span><span class="k">const</span><span class="w"> </span><span class="n">mini_jit</span><span class="o">::</span><span class="n">ir</span><span class="o">::</span><span class="n">Dimension</span><span class="o">&amp;</span><span class="w"> </span><span class="n">dim</span><span class="p">)</span>
<span class="w">                               </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">dim</span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">dim_t</span><span class="o">::</span><span class="n">c</span><span class="p">;</span><span class="w"> </span><span class="p">});</span>

<span class="k">auto</span><span class="w"> </span><span class="n">l_has_k_dim</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">any_of</span><span class="p">(</span><span class="n">dimensions</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">dimensions</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="p">[](</span><span class="k">const</span><span class="w"> </span><span class="n">mini_jit</span><span class="o">::</span><span class="n">ir</span><span class="o">::</span><span class="n">Dimension</span><span class="o">&amp;</span><span class="w"> </span><span class="n">dim</span><span class="p">)</span>
<span class="w">                               </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">dim</span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">dim_t</span><span class="o">::</span><span class="n">k</span><span class="p">;</span><span class="w"> </span><span class="p">});</span>
</pre></div>
</div>
</div>
<p>If we find a <code class="docutils literal notranslate"><span class="pre">C</span></code> dimension, we assume that the current operation is a unary operation.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">l_has_k_dim</span></code> is true, the operation to be optimized is a ternary operation and if it is false, it is a binary operation. Sine the following code is rather complex, we decided to briefly describe it using words instead.</p>
<section id="unary-operation">
<h4>5.5.1.1 Unary Operation<a class="headerlink" href="#unary-operation" title="Link to this heading"></a></h4>
<p>In this case, we first check if all dimensions are of type <code class="docutils literal notranslate"><span class="pre">C</span></code>.
Only then it is a valid unary operation and we can start identifying the primitive dimensions.</p>
<p>First, we identify the primitive <code class="docutils literal notranslate"><span class="pre">M</span></code> dimension as the dimension which has unit stride in the input tensor.
If that dimension does not have unit stride in the output tensor, we assume that the unary operation uses transposition.</p>
<p>In case of transposition, the primitive <code class="docutils literal notranslate"><span class="pre">N</span></code> dimension is the one with unit stride in the output tensor.
If there is no transposition, we choose the dimension with the smallest stride in the input tensor.
That excludes the previously identified <code class="docutils literal notranslate"><span class="pre">M</span></code> dimension.</p>
<p>Lastly, we set all remaining dimensions to <code class="docutils literal notranslate"><span class="pre">sequential</span></code>.</p>
</section>
<section id="binary-operation">
<h4>5.5.1.2 Binary Operation<a class="headerlink" href="#binary-operation" title="Link to this heading"></a></h4>
<p>In binary operations, the primitive <code class="docutils literal notranslate"><span class="pre">M</span></code> dimension has unit stride in all tensors and can thus be identified easily.
For the primitive <code class="docutils literal notranslate"><span class="pre">N</span></code> dimension, we simply choose the dimension of type <code class="docutils literal notranslate"><span class="pre">N</span></code> that has the smallest strides.</p>
</section>
<section id="ternary-operation">
<h4>5.5.1.3 Ternary Operation<a class="headerlink" href="#ternary-operation" title="Link to this heading"></a></h4>
<p>We first check for a second <code class="docutils literal notranslate"><span class="pre">K</span></code> dimension, which has no unit stride in the second input tensor and does not appear in the output tensor.
If such a <code class="docutils literal notranslate"><span class="pre">K</span></code> dimension exists, we select it as the batch-reduce dimension and conclude that the current operation is a BRGEMM.
If no such <code class="docutils literal notranslate"><span class="pre">K</span></code> dimension exists, we are handling a GEMM.</p>
<p>Next, we identify the primitive <code class="docutils literal notranslate"><span class="pre">M</span></code> dimension by checking for an <code class="docutils literal notranslate"><span class="pre">M</span></code> dimension with unit stride in the first input and output tensor.</p>
<p>The primary <code class="docutils literal notranslate"><span class="pre">N</span></code> dimension is then found by choosing the dimension with the smallest stride which appears only in the second input tensor and in the output tensor.</p>
<p>Lastly, we identify the primitive <code class="docutils literal notranslate"><span class="pre">K</span></code> dimension by searching for a <code class="docutils literal notranslate"><span class="pre">K</span></code> dimension that has unit stride in the second input tensor and does not appear in the output tensor.</p>
</section>
</section>
<section id="dimension-splitting">
<h3>5.5.2 Dimension Splitting<a class="headerlink" href="#dimension-splitting" title="Link to this heading"></a></h3>
<p>For our second optimization pass we decided to look at the dimension sizes of our loops.
We introduced a <code class="docutils literal notranslate"><span class="pre">max_kernel_size</span></code> parameter, which specifies the maximum allowed size for a dimension.
If a dimension size exceeds the maximum size, the dimension splitter will try to split it into new dimensions with optimized sizes.
The entry point for this optimization is the <code class="docutils literal notranslate"><span class="pre">splitDimensions</span></code> function:</p>
<div class="literal-block-wrapper docutils container" id="id28">
<div class="code-block-caption"><span class="caption-text">splitDimensions function of the Optimizer</span><a class="headerlink" href="#id28" title="Link to this code"></a></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">mini_jit::ir::Optimizer::splitDimensions</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">mini_jit</span><span class="o">::</span><span class="n">ir</span><span class="o">::</span><span class="n">Dimension</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">dimensions</span><span class="p">,</span>
<span class="w">                                              </span><span class="kt">int64_t</span><span class="w"> </span><span class="n">max_kernel_size</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Dimensions should be split if they are too large (&gt; max_kernel_size)</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">dimensions</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">dimensions</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">max_kernel_size</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="kt">int64_t</span><span class="w"> </span><span class="n">l_size_dim_0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">            </span><span class="kt">int64_t</span><span class="w"> </span><span class="n">l_size_dim_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">            </span><span class="n">findBestSplit</span><span class="p">(</span><span class="n">dimensions</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span><span class="p">,</span>
<span class="w">                          </span><span class="n">max_kernel_size</span><span class="p">,</span>
<span class="w">                          </span><span class="n">dimensions</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">type</span><span class="p">,</span>
<span class="w">                          </span><span class="n">l_size_dim_0</span><span class="p">,</span>
<span class="w">                          </span><span class="n">l_size_dim_1</span><span class="p">);</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">l_size_dim_0</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="c1">// create a new seq dimension</span>
<span class="w">                </span><span class="n">mini_jit</span><span class="o">::</span><span class="n">ir</span><span class="o">::</span><span class="n">Dimension</span><span class="w"> </span><span class="n">l_dim_new</span><span class="p">(</span><span class="n">dimensions</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">type</span><span class="p">,</span>
<span class="w">                                                  </span><span class="n">exec_t</span><span class="o">::</span><span class="n">seq</span><span class="p">,</span>
<span class="w">                                                  </span><span class="n">l_size_dim_0</span><span class="p">,</span>
<span class="w">                                                  </span><span class="n">dimensions</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">stride_in0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">l_size_dim_1</span><span class="p">,</span>
<span class="w">                                                  </span><span class="n">dimensions</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">stride_in1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">l_size_dim_1</span><span class="p">,</span>
<span class="w">                                                  </span><span class="n">dimensions</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">stride_out</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">l_size_dim_1</span><span class="p">);</span>
<span class="w">                </span><span class="c1">// update the original dimension size</span>
<span class="w">                </span><span class="n">dimensions</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">l_size_dim_1</span><span class="p">;</span>
<span class="w">                </span><span class="c1">// insert the new dimension at the back, so it will be checked for a split again</span>
<span class="w">                </span><span class="n">dimensions</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">l_dim_new</span><span class="p">);</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<p>For each dimension, it finds the bets split for our kernels if the dimension size is too large and creates a new dimension.
The size of the original dimension is updated to <code class="docutils literal notranslate"><span class="pre">l_size_dim_1</span></code>, and it will be smaller than or equal to <code class="docutils literal notranslate"><span class="pre">max_kernel_size</span></code>. However, the new dimension <code class="docutils literal notranslate"><span class="pre">l_dim_new</span></code> might still have a larger dimension size than <code class="docutils literal notranslate"><span class="pre">max_kernel_size</span></code>, which is why it is inserted at the end of the dimensions vector, where it will be checked for a possible split in a later iteration.</p>
<p>But what does <code class="docutils literal notranslate"><span class="pre">findBestSplit</span></code> do?</p>
<p>The way our kernels were implemented makes their execution more efficient for specific dimension sizes. Considering the <strong>M</strong> dimension, a size that is a multiple of <strong>16</strong> is optimal for most kernels, since we manually optimized the kernels for this case. As for the <strong>N</strong> dimension size, a multiple of <strong>4</strong> is optimal for most kernels.
In the <strong>K</strong> dimension, we do not have such optimizations and the dimension size can be chosen freely, as long as it is smaller than <code class="docutils literal notranslate"><span class="pre">max_kernel_size</span></code>.
The following code snippet shows the implementation of <code class="docutils literal notranslate"><span class="pre">findBestSplit</span></code> for the <strong>M</strong> and <strong>N</strong> dimensions:</p>
<div class="literal-block-wrapper docutils container" id="id29">
<div class="code-block-caption"><span class="caption-text">findBestSplit function of the Optimizer for M and N</span><a class="headerlink" href="#id29" title="Link to this code"></a></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">o_size_0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="n">o_size_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i_size</span><span class="p">;</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i_type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">dim_t</span><span class="o">::</span><span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// multiples of (multiples of) 4 are efficient (LDP, STP)</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int64_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">findLargestMultipleOfDivisor</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">i_size</span><span class="p">,</span><span class="w"> </span><span class="n">i_max_kernel_size</span><span class="p">,</span><span class="w"> </span><span class="n">o_size_0</span><span class="p">,</span><span class="w"> </span><span class="n">o_size_1</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">o_size_0</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// split by 2</span>
<span class="w">    </span><span class="n">findLargestMultipleOfDivisor</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">i_size</span><span class="p">,</span><span class="w"> </span><span class="n">i_max_kernel_size</span><span class="p">,</span><span class="w"> </span><span class="n">o_size_0</span><span class="p">,</span><span class="w"> </span><span class="n">o_size_1</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">o_size_0</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
<span class="c1">// for n, we want multiples of 4</span>
<span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i_type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">dim_t</span><span class="o">::</span><span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// split by 4</span>
<span class="w">    </span><span class="n">findLargestMultipleOfDivisor</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="n">i_size</span><span class="p">,</span><span class="w"> </span><span class="n">i_max_kernel_size</span><span class="p">,</span><span class="w"> </span><span class="n">o_size_0</span><span class="p">,</span><span class="w"> </span><span class="n">o_size_1</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">o_size_0</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// split by 2</span>
<span class="w">    </span><span class="n">findLargestMultipleOfDivisor</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">i_size</span><span class="p">,</span><span class="w"> </span><span class="n">i_max_kernel_size</span><span class="p">,</span><span class="w"> </span><span class="n">o_size_0</span><span class="p">,</span><span class="w"> </span><span class="n">o_size_1</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">o_size_0</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<p>But what does <code class="docutils literal notranslate"><span class="pre">findLargestMultipleOfDivisor</span></code> do?</p>
<p>As the name suggests, this helper function tries to find the largest multiple of a given divisor. Let’s say the given divisor is <code class="docutils literal notranslate"><span class="pre">16</span></code>, the input dimension size is <strong>1600</strong> and the <code class="docutils literal notranslate"><span class="pre">i_max_kernel_size</span></code> is <strong>1024</strong>.
Then, <code class="docutils literal notranslate"><span class="pre">findLargestMultipleOfDivisor</span></code> will try to find the largest multiple of <strong>16</strong> which divides <strong>1600</strong> and is smaller than or equal to <strong>1024</strong>. The result of this computation is <strong>2</strong> for <code class="docutils literal notranslate"><span class="pre">o_size_0</span></code> and <strong>800</strong> for <code class="docutils literal notranslate"><span class="pre">o_size_1</span></code>.
For the more curious reader, the implementation of <code class="docutils literal notranslate"><span class="pre">findLargestMultipleOfDivisor</span></code> is given below:</p>
<div class="literal-block-wrapper docutils container" id="id30">
<div class="code-block-caption"><span class="caption-text"><code class="docutils literal notranslate"><span class="pre">findLargestMultipleOfDivisor</span></code> function of the Optimizer</span><a class="headerlink" href="#id30" title="Link to this code"></a></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">mini_jit::ir::Optimizer::findLargestMultipleOfDivisor</span><span class="p">(</span><span class="kt">int64_t</span><span class="w"> </span><span class="n">i_divisor</span><span class="p">,</span>
<span class="w">                                                           </span><span class="kt">int64_t</span><span class="w"> </span><span class="n">i_size</span><span class="p">,</span>
<span class="w">                                                           </span><span class="kt">int64_t</span><span class="w"> </span><span class="n">i_max_size</span><span class="p">,</span>
<span class="w">                                                           </span><span class="kt">int64_t</span><span class="w"> </span><span class="o">&amp;</span><span class="n">o_size_0</span><span class="p">,</span>
<span class="w">                                                           </span><span class="kt">int64_t</span><span class="w"> </span><span class="o">&amp;</span><span class="n">o_size_1</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i_divisor</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">i_size</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">i_max_size</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">i_divisor</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">i_max_size</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// start: largest multiple of i_divisor &lt; i_max_size</span>
<span class="w">    </span><span class="kt">int64_t</span><span class="w"> </span><span class="n">l_max_divisible</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">i_max_size</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">i_divisor</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">i_divisor</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int64_t</span><span class="w"> </span><span class="n">l_m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">l_max_divisible</span><span class="p">;</span><span class="w"> </span><span class="n">l_m</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">i_divisor</span><span class="p">;</span><span class="w"> </span><span class="n">l_m</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="n">i_divisor</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// we found an m that divides i_size! it is also the largest</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i_size</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">l_m</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">o_size_0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i_size</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">l_m</span><span class="p">;</span>
<span class="w">            </span><span class="n">o_size_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">l_m</span><span class="p">;</span>
<span class="w">            </span><span class="k">return</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</section>
<section id="id3">
<h3>5.5.3 Shared Memory Parallelization<a class="headerlink" href="#id3" title="Link to this heading"></a></h3>
<p>Our third optimization pass was to make all loops that were not a <code class="docutils literal notranslate"><span class="pre">prim</span></code> dimension and of the dimension type <code class="docutils literal notranslate"><span class="pre">M</span></code> or <code class="docutils literal notranslate"><span class="pre">N</span></code> a <code class="docutils literal notranslate"><span class="pre">shared</span></code> loop.
For that we initially check how many loops are already of dimension type <code class="docutils literal notranslate"><span class="pre">shared</span></code>:</p>
<div class="literal-block-wrapper docutils container" id="id31">
<div class="code-block-caption"><span class="caption-text">Count already existing shared iterations</span><a class="headerlink" href="#id31" title="Link to this code"></a></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">int64_t</span><span class="w"> </span><span class="n">l_num_threads</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>

<span class="c1">// Count the number of existing iterations for shared loops</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">dimensions</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">dimensions</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">exec_type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">exec_t</span><span class="o">::</span><span class="n">shared</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// increase thread number for each existing shared dimension</span>
<span class="w">        </span><span class="n">l_num_threads</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">dimensions</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<p>For the case that we already have a high number of <code class="docutils literal notranslate"><span class="pre">shared</span></code> loops we do not create any more and simply return.
Otherwise we check the <code class="docutils literal notranslate"><span class="pre">seq</span></code> dimensions for potential candidates:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">l_num_threads</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">thread_target</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// make sure that the shared loops are at the front</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">stable_partition</span><span class="p">(</span><span class="n">dimensions</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">dimensions</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="p">[](</span><span class="k">const</span><span class="w"> </span><span class="n">mini_jit</span><span class="o">::</span><span class="n">ir</span><span class="o">::</span><span class="n">Dimension</span><span class="o">&amp;</span><span class="w"> </span><span class="n">dim</span><span class="p">)</span>
<span class="w">                          </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">dim</span><span class="p">.</span><span class="n">exec_type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">exec_t</span><span class="o">::</span><span class="n">shared</span><span class="p">;</span><span class="w"> </span><span class="p">});</span>
<span class="w">    </span><span class="c1">// no need to create more shared loops</span>
<span class="w">    </span><span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Creation of new shared loops:</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">dimensions</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// if the dimension can be set to shared and we did not reach the target number of threads yet</span>
<span class="w">    </span><span class="c1">// we set the dimension to shared</span>
<span class="w">    </span><span class="c1">// also dont parallelize the k dimension (see class slides)</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">dimensions</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">exec_type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">exec_t</span><span class="o">::</span><span class="n">seq</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">dimensions</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">exec_type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">exec_t</span><span class="o">::</span><span class="n">undefined</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span>
<span class="w">        </span><span class="n">dimensions</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">type</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">dim_t</span><span class="o">::</span><span class="n">k</span><span class="w"> </span><span class="o">&amp;&amp;</span>
<span class="w">        </span><span class="n">l_num_threads</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">dimensions</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">thread_target</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">dimensions</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">exec_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">exec_t</span><span class="o">::</span><span class="n">shared</span><span class="p">;</span>
<span class="w">        </span><span class="n">l_num_threads</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">dimensions</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>As a last step we move all our <code class="docutils literal notranslate"><span class="pre">shared</span></code> loops to the front of the order:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Move all shared loops to the front</span>
<span class="n">std</span><span class="o">::</span><span class="n">stable_partition</span><span class="p">(</span><span class="n">dimensions</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">dimensions</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="p">[](</span><span class="k">const</span><span class="w"> </span><span class="n">mini_jit</span><span class="o">::</span><span class="n">ir</span><span class="o">::</span><span class="n">Dimension</span><span class="o">&amp;</span><span class="w"> </span><span class="n">dim</span><span class="p">)</span>
<span class="w">                      </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">dim</span><span class="p">.</span><span class="n">exec_type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">exec_t</span><span class="o">::</span><span class="n">shared</span><span class="p">;</span><span class="w"> </span><span class="p">});</span>
</pre></div>
</div>
</section>
<section id="dimension-fusion">
<span id="id4"></span><h3>5.5.4 Dimension Fusion<a class="headerlink" href="#dimension-fusion" title="Link to this heading"></a></h3>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This part of the Optimizer was implemented much later, as part of the <a class="reference internal" href="07_individual_phase.html#project-week-2"><span class="std std-ref">7.4 Progress of Week 2</span></a> of our final project phase.</p>
</div>
<p>The idea behind <strong>Dimension Fusion</strong> is that when certain dimensions have very small sizes, fusing them can improve cache efficiency and simplify tensor expressions. It also enables our existing dimension splitter to operate more effectively, as it can now split the fused dimensions in ways optimized for our kernels, rather than being constrained by the original tensor structure. In other words, <strong>Dimension Fusion</strong> will be the first step in our optimizer, simplifying the tensor expression upfront so it can then be split in an optimized way and finally, have its primitive dimensions identified.</p>
<p>The first step was to introduce a new <code class="docutils literal notranslate"><span class="pre">min_kernel_size</span></code> parameter. It allows the user to specify the minimum dimension size a kernel should have. If a dimension is smaller than that, the dimension fuser will try to look for candidates to fuse with. This process happens in the new <code class="docutils literal notranslate"><span class="pre">fuseDimensions</span></code> function of the Optimizer.</p>
<div class="literal-block-wrapper docutils container" id="id32">
<div class="code-block-caption"><span class="caption-text">Dimension Fusing in the Optimizer</span><a class="headerlink" href="#id32" title="Link to this code"></a></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">mini_jit::ir::Optimizer::fuseDimensions</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">mini_jit</span><span class="o">::</span><span class="n">ir</span><span class="o">::</span><span class="n">Dimension</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">dimensions</span><span class="p">,</span>
<span class="w">                                             </span><span class="kt">int64_t</span><span class="w"> </span><span class="n">min_kernel_size</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">dimensions</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">mini_jit</span><span class="o">::</span><span class="n">ir</span><span class="o">::</span><span class="n">Dimension</span><span class="w"> </span><span class="o">&amp;</span><span class="n">l_dim_0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dimensions</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">l_dim_0</span><span class="p">.</span><span class="n">size</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">min_kernel_size</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// find a dimension that can be fused with the current one</span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">dimensions</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="k">continue</span><span class="p">;</span><span class="w"> </span><span class="c1">// skip self</span>

<span class="w">                </span><span class="n">mini_jit</span><span class="o">::</span><span class="n">ir</span><span class="o">::</span><span class="n">Dimension</span><span class="w"> </span><span class="o">&amp;</span><span class="n">l_dim_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dimensions</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">l_dim_0</span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">l_dim_1</span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">&amp;&amp;</span>
<span class="w">                    </span><span class="p">(</span><span class="n">l_dim_0</span><span class="p">.</span><span class="n">exec_type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">l_dim_1</span><span class="p">.</span><span class="n">exec_type</span><span class="w"> </span><span class="o">||</span>
<span class="w">                    </span><span class="n">l_dim_0</span><span class="p">.</span><span class="n">exec_type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">exec_t</span><span class="o">::</span><span class="n">undefined</span><span class="w"> </span><span class="o">||</span>
<span class="w">                    </span><span class="n">l_dim_1</span><span class="p">.</span><span class="n">exec_type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">exec_t</span><span class="o">::</span><span class="n">undefined</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span>
<span class="w">                    </span><span class="n">l_dim_1</span><span class="p">.</span><span class="n">stride_in0</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">l_dim_0</span><span class="p">.</span><span class="n">size</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">l_dim_0</span><span class="p">.</span><span class="n">stride_in0</span><span class="w"> </span><span class="o">&amp;&amp;</span>
<span class="w">                    </span><span class="n">l_dim_1</span><span class="p">.</span><span class="n">stride_in1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">l_dim_0</span><span class="p">.</span><span class="n">size</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">l_dim_0</span><span class="p">.</span><span class="n">stride_in1</span><span class="w"> </span><span class="o">&amp;&amp;</span>
<span class="w">                    </span><span class="n">l_dim_1</span><span class="p">.</span><span class="n">stride_out</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">l_dim_0</span><span class="p">.</span><span class="n">size</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">l_dim_0</span><span class="p">.</span><span class="n">stride_out</span><span class="p">)</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="c1">// fuse the two dimensions</span>
<span class="w">                    </span><span class="n">l_dim_0</span><span class="p">.</span><span class="n">size</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">l_dim_1</span><span class="p">.</span><span class="n">size</span><span class="p">;</span>
<span class="w">                    </span><span class="c1">// remove the fused dimension</span>
<span class="w">                    </span><span class="n">dimensions</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">dimensions</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="p">);</span>
<span class="w">                    </span><span class="n">j</span><span class="o">--</span><span class="p">;</span><span class="w"> </span><span class="c1">// adjust index after erasing</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<p>Here, <code class="docutils literal notranslate"><span class="pre">l_dim_0</span></code> is the dimension whose size is smaller than <code class="docutils literal notranslate"><span class="pre">min_kernel_size</span></code>, meaning that we would like to fuse it with another candidate. However, the candidate (<code class="docutils literal notranslate"><span class="pre">l_dim_1</span></code>) the function looks for needs to fulfill some criteria:</p>
<ol class="arabic simple">
<li><p>Same dimension type as <code class="docutils literal notranslate"><span class="pre">l_dim_0</span></code> (<strong>M, N, K, C</strong>)</p></li>
<li><p>Same execution type as <code class="docutils literal notranslate"><span class="pre">l_dim_0</span></code>, or either type is undefined</p></li>
<li><p>The stride of <code class="docutils literal notranslate"><span class="pre">l_dim_1</span></code> needs to equal the product of the stride and size of <code class="docutils literal notranslate"><span class="pre">l_dim_0</span></code> (Two dimensions X and Y can be fused can be fused if for all tensors: <strong>stride(X) = |Y| ⨉ stride(Y)</strong>)</p></li>
</ol>
<p>If a fitting candidate has been found, <code class="docutils literal notranslate"><span class="pre">l_dim_0</span></code> and <code class="docutils literal notranslate"><span class="pre">l_dim_1</span></code> can be fused. This involves multiplying the dimension sizes and removing the candidate from the dimensions vector. The strides do not need to be adjusted, as the original stride of the small <code class="docutils literal notranslate"><span class="pre">l_dim_0</span></code> is still correct.</p>
<p>After implementing dimension fusion, we also had to make adjustments to the dimension splitter. Previously, we would split dimensions by finding the largest possible split for one dimension. For example, if the given dimension size was <strong>1600</strong> and the maximum kernel size <strong>1024</strong>, the function would have returned <strong>2</strong> for <code class="docutils literal notranslate"><span class="pre">o_size_0</span></code> and <strong>800</strong> for <code class="docutils literal notranslate"><span class="pre">o_size_1</span></code>. This is because <strong>800</strong> is the largest multiple of <strong>16</strong> that is less than or equal to <strong>1024</strong>. This was problematic however, because we then had a dimension of size <strong>2</strong>, which was very small and could have lead to inefficiencies. Our solution to this problem was to also introduce the <code class="docutils literal notranslate"><span class="pre">min_kernel_size</span></code> parameter to the dimension splitter as well. Specifically, we adjusted the <code class="docutils literal notranslate"><span class="pre">findBestSplit</span></code> function, which now returns a split if the <code class="docutils literal notranslate"><span class="pre">minimum_kernel_size</span></code> is reached:</p>
<div class="literal-block-wrapper docutils container" id="id33">
<div class="code-block-caption"><span class="caption-text">Updated findBestSplit function for <strong>M</strong> dimensions</span><a class="headerlink" href="#id33" title="Link to this code"></a></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i_type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">dim_t</span><span class="o">::</span><span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// multiples of (multiples of) 4 are efficient (LDP, STP)</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int64_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">findLargestMultipleOfDivisor</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">i_size</span><span class="p">,</span><span class="w"> </span><span class="n">i_max_kernel_size</span><span class="p">,</span><span class="w"> </span><span class="n">i_min_kernel_size</span><span class="p">,</span><span class="w"> </span><span class="n">o_size_0</span><span class="p">,</span><span class="w"> </span><span class="n">o_size_1</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">o_size_0</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">i_min_kernel_size</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// split by 2</span>
<span class="w">    </span><span class="n">findLargestMultipleOfDivisor</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">i_size</span><span class="p">,</span><span class="w"> </span><span class="n">i_max_kernel_size</span><span class="p">,</span><span class="w"> </span><span class="n">i_min_kernel_size</span><span class="p">,</span><span class="w"> </span><span class="n">o_size_0</span><span class="p">,</span><span class="w"> </span><span class="n">o_size_1</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">o_size_0</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">i_min_kernel_size</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<p>Consequently, <code class="docutils literal notranslate"><span class="pre">findLargestMultipleOfDivisor</span></code> had to be adjusted as well, with a simple if-condition:</p>
<div class="literal-block-wrapper docutils container" id="id34">
<div class="code-block-caption"><span class="caption-text">Updated findLargestMultipleOfDivisor functionalities</span><a class="headerlink" href="#id34" title="Link to this code"></a></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">mini_jit::ir::Optimizer::findLargestMultipleOfDivisor</span><span class="p">(</span><span class="kt">int64_t</span><span class="w"> </span><span class="n">i_divisor</span><span class="p">,</span>
<span class="w">                                                          </span><span class="kt">int64_t</span><span class="w"> </span><span class="n">i_size</span><span class="p">,</span>
<span class="w">                                                          </span><span class="kt">int64_t</span><span class="w"> </span><span class="n">i_max_size</span><span class="p">,</span>
<span class="w">                                                          </span><span class="kt">int64_t</span><span class="w"> </span><span class="n">i_min_size</span><span class="p">,</span>
<span class="w">                                                          </span><span class="kt">int64_t</span><span class="w"> </span><span class="o">&amp;</span><span class="n">o_size_0</span><span class="p">,</span>
<span class="w">                                                          </span><span class="kt">int64_t</span><span class="w"> </span><span class="o">&amp;</span><span class="n">o_size_1</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i_divisor</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">i_size</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">i_max_size</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">i_min_size</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">||</span>
<span class="w">        </span><span class="n">i_divisor</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">i_max_size</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">i_size</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">i_min_size</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// start: largest multiple of i_divisor &lt; i_max_size</span>
<span class="w">    </span><span class="kt">int64_t</span><span class="w"> </span><span class="n">l_max_divisible</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">i_max_size</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">i_divisor</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">i_divisor</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int64_t</span><span class="w"> </span><span class="n">l_m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">l_max_divisible</span><span class="p">;</span><span class="w"> </span><span class="n">l_m</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">i_divisor</span><span class="p">;</span><span class="w"> </span><span class="n">l_m</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="n">i_divisor</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// we found an m that divides i_size! it is also the largest</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i_size</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">l_m</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="kt">int64_t</span><span class="w"> </span><span class="n">candidate_size_0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i_size</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">l_m</span><span class="p">;</span>
<span class="w">            </span><span class="kt">int64_t</span><span class="w"> </span><span class="n">candidate_size_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">l_m</span><span class="p">;</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">candidate_size_0</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">i_min_size</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">candidate_size_1</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">i_min_size</span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">o_size_0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">candidate_size_0</span><span class="p">;</span>
<span class="w">                </span><span class="n">o_size_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">candidate_size_1</span><span class="p">;</span>
<span class="w">                </span><span class="k">return</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<p>Candidates for splitting are now only chosen if both dimension sizes are at least as large as the specified minimum kernel size.
Therefore, the new dimension splitter now outputs <strong>50</strong> and <strong>32</strong> as a split of <strong>1600</strong>, if <code class="docutils literal notranslate"><span class="pre">min_kernel_size</span></code> is set to <strong>16</strong>.</p>
</section>
<section id="performance-benchmarks">
<span id="id5"></span><h3>5.5.6 Performance Benchmarks<a class="headerlink" href="#performance-benchmarks" title="Link to this heading"></a></h3>
<p>We performed benchmarks using different parameters to see what effect they have on the performance.
We obtained the following results:</p>
<div class="literal-block-wrapper docutils container" id="id35">
<div class="code-block-caption"><span class="caption-text"><code class="docutils literal notranslate"><span class="pre">GFLOP</span></code> performance for sample configurations</span><a class="headerlink" href="#id35" title="Link to this code"></a></div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span>Running SharedTensorOperationBench benchmark #1
<span class="linenos"> 2</span>Total time (s):                  3.01164
<span class="linenos"> 3</span>Total reps:                      101
<span class="linenos"> 4</span>Total floating point operations: 827392000000
<span class="linenos"> 5</span>Estimated GFLOPS/sec:            274.731
<span class="linenos"> 6</span>--------------------------------------------------
<span class="linenos"> 7</span>#####################################################
<span class="linenos"> 8</span>Testing different kernel sizes
<span class="linenos"> 9</span>#####################################################
<span class="linenos">10</span>Running SharedTensorOperationBench benchmark (thread_target: 64, max_kernel_size: 1024)
<span class="linenos">11</span>Total time (s):                  3.02859
<span class="linenos">12</span>Total reps:                      105
<span class="linenos">13</span>Total floating point operations: 860160000000
<span class="linenos">14</span>Estimated GFLOPS/sec:            284.013
<span class="linenos">15</span>--------------------------------------------------
<span class="linenos">16</span>Running SharedTensorOperationBench benchmark (thread_target: 256, max_kernel_size: 1024)
<span class="linenos">17</span>Total time (s):                  3.02753
<span class="linenos">18</span>Total reps:                      105
<span class="linenos">19</span>Total floating point operations: 860160000000
<span class="linenos">20</span>Estimated GFLOPS/sec:            284.113
<span class="linenos">21</span>--------------------------------------------------
<span class="linenos">22</span>Running SharedTensorOperationBench benchmark (thread_target: 64, max_kernel_size: 512)
<span class="linenos">23</span>Total time (s):                  3.0037
<span class="linenos">24</span>Total reps:                      95
<span class="linenos">25</span>Total floating point operations: 778240000000
<span class="linenos">26</span>Estimated GFLOPS/sec:            259.093
<span class="linenos">27</span>--------------------------------------------------
<span class="linenos">28</span>Running SharedTensorOperationBench benchmark (thread_target: 256, max_kernel_size: 512)
<span class="linenos">29</span>Total time (s):                  3.00784
<span class="linenos">30</span>Total reps:                      95
<span class="linenos">31</span>Total floating point operations: 778240000000
<span class="linenos">32</span>Estimated GFLOPS/sec:            258.738
<span class="linenos">33</span>--------------------------------------------------
<span class="linenos">34</span>Running SharedTensorOperationBench benchmark (thread_target: 64, max_kernel_size: 256)
<span class="linenos">35</span>Total time (s):                  3.01035
<span class="linenos">36</span>Total reps:                      112
<span class="linenos">37</span>Total floating point operations: 917504000000
<span class="linenos">38</span>Estimated GFLOPS/sec:            304.783
<span class="linenos">39</span>--------------------------------------------------
<span class="linenos">40</span>Running SharedTensorOperationBench benchmark (thread_target: 256, max_kernel_size: 256)
<span class="linenos">41</span>Total time (s):                  3.00121
<span class="linenos">42</span>Total reps:                      110
<span class="linenos">43</span>Total floating point operations: 901120000000
<span class="linenos">44</span>Estimated GFLOPS/sec:            300.253
<span class="linenos">45</span>--------------------------------------------------
<span class="linenos">46</span>Running SharedTensorOperationBench benchmark (thread_target: 64, max_kernel_size: 125)
<span class="linenos">47</span>Total time (s):                  3.00583
<span class="linenos">48</span>Total reps:                      129
<span class="linenos">49</span>Total floating point operations: 1056768000000
<span class="linenos">50</span>Estimated GFLOPS/sec:            351.573
<span class="linenos">51</span>--------------------------------------------------
<span class="linenos">52</span>Running SharedTensorOperationBench benchmark (thread_target: 256, max_kernel_size: 125)
<span class="linenos">53</span>Total time (s):                  3.00655
<span class="linenos">54</span>Total reps:                      129
<span class="linenos">55</span>Total floating point operations: 1056768000000
<span class="linenos">56</span>Estimated GFLOPS/sec:            351.488
<span class="linenos">57</span>--------------------------------------------------
<span class="linenos">58</span>Running SharedTensorOperationBench benchmark (thread_target: 64, max_kernel_size: 64)
<span class="linenos">59</span>Total time (s):                  3.01405
<span class="linenos">60</span>Total reps:                      119
<span class="linenos">61</span>Total floating point operations: 974848000000
<span class="linenos">62</span>Estimated GFLOPS/sec:            323.435
<span class="linenos">63</span>--------------------------------------------------
<span class="linenos">64</span>Running SharedTensorOperationBench benchmark (thread_target: 256, max_kernel_size: 64)
<span class="linenos">65</span>Total time (s):                  3.01289
<span class="linenos">66</span>Total reps:                      119
<span class="linenos">67</span>Total floating point operations: 974848000000
<span class="linenos">68</span>Estimated GFLOPS/sec:            323.559
<span class="linenos">69</span>--------------------------------------------------
<span class="linenos">70</span>Running SharedTensorOperationBench benchmark (thread_target: 64, max_kernel_size: 32)
<span class="linenos">71</span>Total time (s):                  3.00815
<span class="linenos">72</span>Total reps:                      125
<span class="linenos">73</span>Total floating point operations: 1024000000000
<span class="linenos">74</span>Estimated GFLOPS/sec:            340.409
<span class="linenos">75</span>--------------------------------------------------
<span class="linenos">76</span>Running SharedTensorOperationBench benchmark (thread_target: 256, max_kernel_size: 32)
<span class="linenos">77</span>Total time (s):                  3.00952
<span class="linenos">78</span>Total reps:                      126
<span class="linenos">79</span>Total floating point operations: 1032192000000
<span class="linenos">80</span>Estimated GFLOPS/sec:            342.975
<span class="linenos">81</span>--------------------------------------------------
<span class="linenos">82</span>Running SharedTensorOperationBench benchmark (thread_target: 64, max_kernel_size: 16)
<span class="linenos">83</span>Total time (s):                  3.0137
<span class="linenos">84</span>Total reps:                      40
<span class="linenos">85</span>Total floating point operations: 327680000000
<span class="linenos">86</span>Estimated GFLOPS/sec:            108.73
<span class="linenos">87</span>--------------------------------------------------
<span class="linenos">88</span>Running SharedTensorOperationBench benchmark (thread_target: 256, max_kernel_size: 16)
<span class="linenos">89</span>Total time (s):                  3.01834
<span class="linenos">90</span>Total reps:                      119
<span class="linenos">91</span>Total floating point operations: 974848000000
<span class="linenos">92</span>Estimated GFLOPS/sec:            322.975
<span class="linenos">93</span>--------------------------------------------------
</pre></div>
</div>
</div>
<p>Depending on the selected dimensions our results varied massively. The highest performance we achieved was around <code class="docutils literal notranslate"><span class="pre">350</span> <span class="pre">GFLOPs</span></code>.</p>
</section>
</section>
<section id="unary-operations">
<span id="id6"></span><h2>5.6 Unary Operations<a class="headerlink" href="#unary-operations" title="Link to this heading"></a></h2>
<section id="backend-extension">
<h3>5.6.1 Backend Extension<a class="headerlink" href="#backend-extension" title="Link to this heading"></a></h3>
<p>In this task, we were supposed to add support for unary operations, such as permuting a tensor’s dimensions, to our tensor operation backend.
Furthermore, we had to implement primitive identification and shared memory parallelization optimization passes for these unary primitives.</p>
<p>Instead of separating the documentation on unary, binary and ternary operations, we decided to merge them.
This means that the code for handling unary operations has already been shown and explained in the previous section(s).</p>
</section>
<section id="reference-implementation">
<h3>5.6.2 Reference Implementation<a class="headerlink" href="#reference-implementation" title="Link to this heading"></a></h3>
<p>For our reference implementation, we used an example with 4 dimensions, <code class="docutils literal notranslate"><span class="pre">trus</span></code>, where we reorder the dimensions to <code class="docutils literal notranslate"><span class="pre">turs</span></code>.</p>
<div class="literal-block-wrapper docutils container" id="id36">
<div class="code-block-caption"><span class="caption-text">Initialization of the tensor sizes</span><a class="headerlink" href="#id36" title="Link to this code"></a></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="n">mini_jit</span><span class="o">::</span><span class="n">ptype_t</span><span class="w"> </span><span class="n">first_touch_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mini_jit</span><span class="o">::</span><span class="n">ptype_t</span><span class="o">::</span><span class="n">none</span><span class="p">;</span>
<span class="k">const</span><span class="w"> </span><span class="n">mini_jit</span><span class="o">::</span><span class="n">ptype_t</span><span class="w"> </span><span class="n">main_type</span><span class="w">        </span><span class="o">=</span><span class="w"> </span><span class="n">mini_jit</span><span class="o">::</span><span class="n">ptype_t</span><span class="o">::</span><span class="n">identity</span><span class="p">;</span>
<span class="k">const</span><span class="w"> </span><span class="n">mini_jit</span><span class="o">::</span><span class="n">ptype_t</span><span class="w"> </span><span class="n">last_touch_type</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">mini_jit</span><span class="o">::</span><span class="n">ptype_t</span><span class="o">::</span><span class="n">none</span><span class="p">;</span>

<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GENERATE</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">);</span>
<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">R</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GENERATE</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">);</span>
<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">U</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GENERATE</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">);</span>
<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">S</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GENERATE</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">);</span>

<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">SIZE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">R</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">U</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">S</span><span class="p">;</span>

<span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">A</span><span class="w">          </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">float</span><span class="p">[</span><span class="n">SIZE</span><span class="p">];</span>
<span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">C</span><span class="w">          </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">float</span><span class="p">[</span><span class="n">SIZE</span><span class="p">];</span>
<span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">C_expected</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">float</span><span class="p">[</span><span class="n">SIZE</span><span class="p">];</span>
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="id37">
<div class="code-block-caption"><span class="caption-text">Filling the tensors with values</span><a class="headerlink" href="#id37" title="Link to this code"></a></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">random_device</span><span class="w">                    </span><span class="n">rd</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">mt19937</span><span class="w">                          </span><span class="nf">gen</span><span class="p">(</span><span class="n">rd</span><span class="p">());</span>
<span class="n">std</span><span class="o">::</span><span class="n">uniform_real_distribution</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="w"> </span><span class="n">dist</span><span class="p">(</span><span class="mf">-10.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">10.0f</span><span class="p">);</span>

<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">SIZE</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dist</span><span class="p">(</span><span class="n">gen</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Compute C_expected</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">T</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">R</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">r</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">U</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">u</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">S</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">s</span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="c1">// Calculate index in output format (t,r,u,s) using strides_out</span>
<span class="w">                </span><span class="kt">int</span><span class="w"> </span><span class="n">l_idx_c_exp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">U</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">R</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">S</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">S</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">R</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">S</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">s</span><span class="p">;</span>
<span class="w">                </span><span class="c1">// Calculate index in input format (t,u,r,s) using strides_in0</span>
<span class="w">                </span><span class="kt">int</span><span class="w"> </span><span class="n">l_idx_a</span><span class="w">             </span><span class="o">=</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">R</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">U</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">S</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">S</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">U</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">S</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">s</span><span class="p">;</span>
<span class="w">                </span><span class="n">C_expected</span><span class="p">[</span><span class="n">l_idx_c_exp</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="n">l_idx_a</span><span class="p">];</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<p>Then we prepared the execution by setting all arguments accordingly:</p>
<div class="literal-block-wrapper docutils container" id="id38">
<div class="code-block-caption"><span class="caption-text">Prepare arguments for execution</span><a class="headerlink" href="#id38" title="Link to this code"></a></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">mini_jit</span><span class="o">::</span><span class="n">dim_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">dim_types</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">mini_jit</span><span class="o">::</span><span class="n">dim_t</span><span class="o">::</span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="c1">// t</span>
<span class="w">    </span><span class="n">mini_jit</span><span class="o">::</span><span class="n">dim_t</span><span class="o">::</span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="c1">// r</span>
<span class="w">    </span><span class="n">mini_jit</span><span class="o">::</span><span class="n">dim_t</span><span class="o">::</span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="c1">// u</span>
<span class="w">    </span><span class="n">mini_jit</span><span class="o">::</span><span class="n">dim_t</span><span class="o">::</span><span class="n">c</span><span class="w">  </span><span class="c1">// s</span>
<span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">mini_jit</span><span class="o">::</span><span class="n">exec_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">exec_types</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">mini_jit</span><span class="o">::</span><span class="n">exec_t</span><span class="o">::</span><span class="n">seq</span><span class="p">,</span><span class="w">  </span><span class="c1">// t</span>
<span class="w">    </span><span class="n">mini_jit</span><span class="o">::</span><span class="n">exec_t</span><span class="o">::</span><span class="n">seq</span><span class="p">,</span><span class="w">  </span><span class="c1">// r</span>
<span class="w">    </span><span class="n">mini_jit</span><span class="o">::</span><span class="n">exec_t</span><span class="o">::</span><span class="n">prim</span><span class="p">,</span><span class="w"> </span><span class="c1">// u</span>
<span class="w">    </span><span class="n">mini_jit</span><span class="o">::</span><span class="n">exec_t</span><span class="o">::</span><span class="n">prim</span><span class="w">  </span><span class="c1">// s</span>
<span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">dim_sizes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">R</span><span class="p">,</span><span class="w"> </span><span class="n">U</span><span class="p">,</span><span class="w"> </span><span class="n">S</span><span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">strides_in0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">R</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">U</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">S</span><span class="p">,</span><span class="w"> </span><span class="c1">// t</span>
<span class="w">    </span><span class="n">U</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">S</span><span class="p">,</span><span class="w">     </span><span class="c1">// r</span>
<span class="w">    </span><span class="n">S</span><span class="p">,</span><span class="w">         </span><span class="c1">// u</span>
<span class="w">    </span><span class="mi">1</span><span class="w">          </span><span class="c1">// s</span>
<span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">strides_in1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">strides_out</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">U</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">R</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">S</span><span class="p">,</span><span class="w"> </span><span class="c1">// t</span>
<span class="w">    </span><span class="n">S</span><span class="p">,</span><span class="w">         </span><span class="c1">// r</span>
<span class="w">    </span><span class="n">R</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">S</span><span class="p">,</span><span class="w">     </span><span class="c1">// u</span>
<span class="w">    </span><span class="mi">1</span><span class="w">          </span><span class="c1">// s</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<p>This code can be found in the <code class="docutils literal notranslate"><span class="pre">TensorOperation.test.cpp</span></code> file. Running the test resulted in a successful pass.</p>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="04_code_gen.html" class="btn btn-neutral float-left" title="4. Code Generation" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="06_einsum.html" class="btn btn-neutral float-right" title="6. Einsum Trees" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Lucas Obitz, Luca-Philipp Grumbach.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>